---
title: "Running scRATE for thousands of genes on a cluster"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{scRATE}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "##"
)
```

Evaluation or comparison of Bayesian models over tens of millions of data points (cells) would be useful but very time consuming. The true utility of *scRATE* lies in its functions that facilitate the throughput on a cluster computing resource and enable the model selection across entire data set, typically containing thousands of genes. For this you will have to first pull singularity (or docker) container:

```{bash eval=FALSE}
$ singularity pull shub://singularityhub/scRATE
```

You can launch a shell with the singularity container followed by an R session on an interactive session:

```{bash eval=FALSE}
$ singularity shell scRATE_latest.sif
$ R
```



```{r setup}
library(loomR)
library(scRATE)
```

To use scRATE's cluster computing support, UMI count matrix (gene x cell) and some minimal meta-data should be encoded in loom file format (See `scRATE::create_loom` function). We use loom format files since it is supported in both `R` and `python`. In `scRATE`, we also provide handy features for processing model selection results and store them in the same loom file.

```{r}
prepare_job_array(loomfile = 'DC-like_cells.loom', num_chunks = 6, outdir='.', dryrun = FALSE)
```

This command generates .RData files that contains UMI count matrix for subset of genes and an accompanying meta-data in addition to two bash scripts `run_subjobs.sh.slurm` and `run_subjobs.sh.pbs`, one for slurm and the other for pbs/torque cluster system. These are scripts to submit a job array, for slurm for example,

```{bash eval=FALSE}
#!/bin/bash
#SBATCH --qos=batch
#SBATCH --partition=compute
#SBATCH --job-name=scRATE
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=4
#SBATCH --mem=16gb
#SBATCH --time=23:59:59
#SBATCH --array=1-6

module load singularity

# Run your R script that uses scRATE singularity container
ARRAY_ID=`printf %05d $SLURM_ARRAY_TASK_ID`
singularity run --app Rscript ${CONTAINER} ${RFILE} _chunk.${ARRAY_ID} _scrate.${ARRAY_ID} ${CORES} ${SEED}
```

To submit this job array, you `sbatch` it with environment variables: `CONTAINER` (the name of scRATE singularity container file we pulled from singularity hub), `RFILE` (an R script file that specifies tasks to execute using scRATE functions), `CORES` (the number of cores to use), and `SEED` (seed number for random number generation). Depending on the R script you created, you will have to modify the arguments for it in those bash scripts.

```{bash eval=FALSE}
$ sbatch --export=CONTAINER=scRATE.sif,RFILE=run_model_comparison.R,CORES=4,SEED=1004 run_subjobs.sh.slurm
```

This will execute `run_model_comparison.R` for every data chunk we made with `prepare_job_array` function above. This R script executes `scRATE::run_model_comparison` function for genes in every data chunk and store the model fit parameters and model selection results in an RDS format file for each data chunk.

```{r eval=FALSE}
#!/usr/bin/env Rscript
args = commandArgs(trailingOnly=TRUE)
if (length(args)!=4) {
  stop("Four arguments must be supplied (<cntfile> <outfile> <cores> <seed>).n", call.=FALSE)
}

library(scRATE)

cntfile <- args[1]
outfile <- args[2]
nCores <- as.integer(args[3])
seed <- as.integer(args[4])

run_model_comparison(cntfile, nCores=nCores, seed=seed, adapt_delta=0.95, outfile=outfile)
```

Once the job array is successfully finished, we collate the model fitting results into a single file for later downstream analyses.

```{r eval=FALSE}
collate_results(loo_dir='.', loo_outfile='DC-like_cells.scrate.rds')
```

Then based on the model fitting results, we select models that best fits each gene.
```{r}
results <- readRDS('DC-like_cells.scrate.rds')
model_call <- list()
model_call[['SE2']] <- perform_model_selection(fit_list=results, margin=2.0, loomfile='DC-like_cells.loom', attr_name='ModelCall_SE0.0', verbose=TRUE)
```

All set!
